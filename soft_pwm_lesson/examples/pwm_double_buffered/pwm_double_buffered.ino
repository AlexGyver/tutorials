/*
    Буфферизация заполнения ШИМ (по-правильному)
    Программный ШИМ, любое разрешение до 8 бит, 3 канала
    Выводим ШИМ на пины А3,A4,A5
    Значение заполнения читаем с потенциометров на пинах A0,A1,A2
*/

#include <GyverTimers.h>  // Либа прерываний по таймеру
#include "FastIO.h"       // Либа быстрого ввода/вывода

#define PWM_DEPTH 15      // Предел счета таймера, определяет разрешение ШИМ
// Можно выбрать от 2 до 254 (больше нельзя)
// В данном случае ШИМ имеет пределы 0 - 15 (4 бита, 16 градаций)

volatile byte dutyA3 = 0; // Переменные для хранения заполнения ШИМ
volatile byte dutyA4 = 0; // Можно упаковать в массив при желании
volatile byte dutyA5 = 0;

void setup() {
  pinMode(A3, OUTPUT); // Все каналы ШИМ устанавливаются как выходы
  pinMode(A4, OUTPUT);
  pinMode(A5, OUTPUT);

  Timer2.setFrequency(40000);     // Заводим прерывания таймера 2 на 40кгц
  Timer2.enableISR();             // Вкл. прерывания таймера
}

void loop() { // Получаем заполнение ШИМ с потенциометров
  dutyA3 = map(analogRead(A0), 0, 1023, 0, PWM_DEPTH); // У каждого канала свой потенциометр
  dutyA4 = map(analogRead(A1), 0, 1023, 0, PWM_DEPTH); // Преобразуем 10 бит АЦП в выбранное разрешение ШИМ
  dutyA5 = map(analogRead(A2), 0, 1023, 0, PWM_DEPTH); // В данном случае 0...1023 -> 0...15
  delay(100);  // Других задач нет - можно поставить delay (иначе ставим millis() таймер)
}


/*
   Софтверный ШИМ
*/
void pwmTick() {
  static volatile uint8_t counter = 0;     // Счетчик
  static volatile uint8_t bufA3 = dutyA3;  // Буфер для тех каналов, где это нужно
  static volatile uint8_t bufA4 = dutyA4;
  static volatile uint8_t bufA5 = dutyA5;

  if (counter > PWM_DEPTH) {
    bufA3 = dutyA3; // Обновляем буферы каналов при новом периоде ШИМ
    bufA4 = dutyA4;
    bufA5 = dutyA5;

    // Переполнение счетчика - все каналы ШИМ устанавливаются в HIGH
    if (bufA3 > 0) fastWrite(A3, HIGH); // Устанавливаем HIGH, только если заполнение >0 (быстрый digitalWrite)
    if (bufA4 > 0) fastWrite(A4, HIGH); // Решает проблему слабого свечения LED при заполнении = 0
    fastWrite(A5, HIGH); // Можно и не проверять на 0, если используется электродвигатель или лампа накаливания
    counter = 0;                // Обнуляем счетчик ВРУЧНУЮ
  }

  if (counter == bufA3) fastWrite(A3, LOW); // Проверяем все каналы на совпадение счетчика со значением заполнения
  if (counter == bufA3) fastWrite(A4, LOW); // При совпадении переводим канал в состояние LOW
  if (counter == bufA3) fastWrite(A5, LOW); // Сравнение идет с буфером, а не напрямую!

  counter++;                                        // Инкремент счетчика
}

ISR(TIMER2_A) {
  pwmTick();    // Тикер ШИМ в прерывании таймера (можно перенести код тикера сюда)
}
